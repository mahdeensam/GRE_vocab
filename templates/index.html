<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GRE Verbal — GRE Master</title>
<meta name="description" content="Master GRE vocabulary with flashcards, concept groups, and Bengali memory hooks. Track your progress across devices.">
<meta property="og:title" content="GRE Vocab Master">
<meta property="og:description" content="Flashcards, concept groups, and Bengali memory hooks — everything you need to conquer the GRE verbal section.">
<meta property="og:image" content="https://gre-vocab.onrender.com/static/og-image.png">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="GRE Vocab Master">
<meta name="twitter:description" content="Flashcards, concept groups, and Bengali memory hooks — everything you need to conquer the GRE verbal section.">
<meta name="twitter:image" content="https://gre-vocab.onrender.com/static/og-image.png">
<link rel="icon" type="image/svg+xml" href="/static/favicon.svg">
<link rel="icon" type="image/png" sizes="32x32" href="/static/favicon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/static/apple-touch-icon.png">
<link rel="stylesheet" href="/static/style.css">
<script src="/static/math-data.js" defer></script>
</head>
<body>

<section id="hero">
  <div class="hero-bg-overlay"></div>
  <div class="hero-content">
    <div class="hero-badge">GRE Master — Verbal Section</div>
    <h1 class="hero-title">Master GRE Vocabulary</h1>
    <p class="hero-tagline">Flashcards, concept groups, and Bengali memory hooks — everything you need to conquer the GRE verbal section.</p>
    <div class="hero-stats">
      <div class="hero-stat">
        <div class="hero-stat-number" data-target="{{ total }}">0</div>
        <div class="hero-stat-label">Words</div>
      </div>
      <div class="hero-stat">
        <div class="hero-stat-number" data-target="{{ concept_group_count }}">0</div>
        <div class="hero-stat-label">Concept Groups</div>
      </div>
      <div class="hero-stat">
        <div class="hero-stat-number" data-target="{{ hook_count }}">0</div>
        <div class="hero-stat-label">Memory Hooks</div>
      </div>
    </div>
    <div class="hero-features">
      <div class="hero-feature" data-target="flashcard" role="button" tabindex="0">
        <div class="hero-feature-icon"><svg viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="4" width="16" height="18" rx="2" opacity="0.3"/><rect x="6" y="2" width="16" height="18" rx="2" fill="var(--surface)" stroke="currentColor"/><line x1="10" y1="8" x2="18" y2="8"/><line x1="10" y1="12" x2="18" y2="12"/><line x1="10" y1="16" x2="15" y2="16"/></svg></div>
        <div class="hero-feature-title">Flashcards</div>
        <div class="hero-feature-desc">Flip through curated decks with spaced repetition tracking</div>
      </div>
      <div class="hero-feature" data-target="list" role="button" tabindex="0">
        <div class="hero-feature-icon"><svg viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/><line x1="8" y1="7" x2="16" y2="7"/><line x1="8" y1="11" x2="14" y2="11"/></svg></div>
        <div class="hero-feature-title">Word List</div>
        <div class="hero-feature-desc">Search, filter, and tag every word — learning, learned, confused, or hard</div>
      </div>
      <div class="hero-feature" data-target="concepts" role="button" tabindex="0">
        <div class="hero-feature-icon"><svg viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 2a7 7 0 0 1 7 7c0 3-2.5 5-5 6.5S12 18 12 22"/><path d="M12 2a7 7 0 0 0-7 7c0 3 2.5 5 5 6.5S12 18 12 22"/><line x1="2" y1="12" x2="22" y2="12"/></svg></div>
        <div class="hero-feature-title">Concept Groups</div>
        <div class="hero-feature-desc">Words grouped by meaning with Bengali translations</div>
      </div>
      <div class="hero-feature" data-target="math" role="button" tabindex="0">
        <div class="hero-feature-icon"><svg viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="3" width="20" height="18" rx="2"/><line x1="7" y1="8" x2="17" y2="8"/><line x1="12" y1="5" x2="12" y2="11"/><line x1="7" y1="16" x2="17" y2="16"/><line x1="7" y1="13" x2="10" y2="13"/><line x1="14" y1="13" x2="17" y2="13"/></svg></div>
        <div class="hero-feature-title">GRE Math</div>
        <div class="hero-feature-desc">Arithmetic, algebra, geometry, data analysis &amp; QC strategies</div>
      </div>
      <div class="hero-feature" data-target="verbal-practice" role="button" tabindex="0">
        <div class="hero-feature-icon"><svg viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="9" y1="13" x2="15" y2="13"/><line x1="9" y1="17" x2="13" y2="17"/></svg></div>
        <div class="hero-feature-title">Practice Questions</div>
        <div class="hero-feature-desc">TC, SE &amp; RC — high-band verbal practice with answer explanations</div>
      </div>
    </div>
    <button class="hero-cta" id="hero-cta">Start Learning &rarr;</button>
    <div id="hero-auth" class="hero-auth">{% if current_user.is_authenticated %}<div class="hero-signed-in">Signed in as <strong>{{ current_user.name or current_user.email }}</strong></div>{% else %}<a href="/auth/google" class="hero-sign-in">Sign in with Google to save progress</a>{% endif %}</div>
    <div class="hero-attribution">A production gift from <strong>Sameernetwork.com</strong></div>
  </div>
</section>

<nav>
  <div class="nav-brand" style="gap:.5rem">
    <a href="/" style="color:var(--muted);text-decoration:none;font-size:.8rem;padding:4px 10px;border:1px solid var(--border);border-radius:6px;transition:all .2s;white-space:nowrap" onmouseover="this.style.borderColor='var(--primary)';this.style.color='var(--primary)'" onmouseout="this.style.borderColor='var(--border)';this.style.color='var(--muted)'">&larr; Home</a>
    <svg class="brand-icon" viewBox="0 0 24 24" width="22" height="22" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
      <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
    </svg>
    <span class="brand-text">GRE Verbal</span>
  </div>
  <div class="nav-links">
    <button class="nav-btn active" data-view="flashcard">Flashcards</button>
    <button class="nav-btn" data-view="list">Word List</button>
    <button class="nav-btn" data-view="concepts">Concept Groups</button>
    <button class="nav-btn" data-view="sleep">Sleep-time Words</button>
    <button class="nav-btn" data-view="math">Math</button>
    <button class="nav-btn" data-view="lookalikes">Look-alikes</button>
  </div>
  <div class="nav-right">
    <div class="nav-stats">{{ total }} words</div>
    <div id="auth-section">{% if current_user.is_authenticated %}<div class="user-menu" id="user-menu">{% if current_user.picture %}<img src="{{ current_user.picture }}" alt="" class="user-avatar" referrerpolicy="no-referrer">{% else %}<div class="user-avatar user-avatar-placeholder">{{ current_user.name[0]|upper if current_user.name else '?' }}</div>{% endif %}<span class="user-name">{{ current_user.name or current_user.email }}</span><div class="user-dropdown" id="user-dropdown"><div class="user-dropdown-email">{{ current_user.email }}</div><a href="/auth/logout" class="user-dropdown-item">Sign Out</a></div></div>{% else %}<a href="/auth/google" class="sign-in-btn">Sign In</a>{% endif %}</div>
    <button class="theme-toggle" id="theme-toggle" title="Toggle theme"></button>
  </div>
</nav>

<!-- FLASHCARD VIEW -->
<section id="flashcard-view" class="view active">
  <div class="flashcard-controls">
    <div class="deck-info">
      <span id="card-counter">1 / 20</span>
      <span id="known-count" class="badge green">0 Known</span>
      <span id="unknown-count" class="badge red">0 Learning</span>
    </div>
    <div class="deck-actions">
      <select id="deck-filter" title="Filter deck by tag">
        <option value="all">All Words</option>
        <option value="learning">Learning Only</option>
        <option value="learned">Learned Only</option>
        <option value="confused">Confused Only</option>
        <option value="hard">Hard Only</option>
        <option value="unmarked">Unmarked Only</option>
      </select>
      <label for="batch-size">Cards:</label>
      <select id="batch-size">
        <option value="10">10</option>
        <option value="20" selected>20</option>
        <option value="50">50</option>
        <option value="100">100</option>
        <option value="all">All</option>
      </select>
      <button id="new-deck-btn" class="btn btn-primary">New Deck</button>
    </div>
  </div>
  <div class="deck-progress-bar"><div class="deck-progress-fill" id="deck-progress"></div></div>

  <div class="flashcard-area">
    <button class="arrow-btn" id="prev-btn">&larr;</button>

    <div class="flashcard-container">
      <div class="flashcard" id="flashcard" onclick="flipCard()">
        <div class="flashcard-front">
          <div class="card-word" id="card-word">Loading...</div>
          <button class="voice-btn" id="voice-btn" onclick="event.stopPropagation(); speakCard()" title="Listen">
            <svg viewBox="0 0 24 24" width="22" height="22" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>
          </button>
          <div class="card-hint">Tap to flip &middot; Swipe to navigate</div>
        </div>
        <div class="flashcard-back">
          <div class="card-section card-hook-section" id="card-hook-section" style="display:none">
            <div class="card-label card-hook-label"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" style="vertical-align:-2px"><path d="M12 2a7 7 0 0 1 7 7c0 3-2.5 5-5 6.5S12 18 12 22"/><path d="M12 2a7 7 0 0 0-7 7c0 3 2.5 5 5 6.5S12 18 12 22"/><line x1="2" y1="12" x2="22" y2="12" stroke-width="1.5" opacity="0.5"/></svg> Memory Hook</div>
            <div class="card-hook-text" id="card-hook"></div>
          </div>
          <div class="card-section">
            <div class="card-label">Meaning</div>
            <div id="card-meaning"></div>
          </div>
          <div class="card-section">
            <div class="card-label">Functional Use</div>
            <div id="card-usage"></div>
          </div>
          <div class="card-section">
            <div class="card-label">NOT Used For</div>
            <div id="card-not-used" class="text-muted"></div>
          </div>
          <div class="card-section">
            <div class="card-label">Example</div>
            <div id="card-example" class="text-italic"></div>
          </div>
        </div>
      </div>
    </div>

    <button class="arrow-btn" id="next-btn">&rarr;</button>
  </div>

  <div class="flashcard-tag-bar" id="flashcard-tag-bar">
    <span class="flashcard-tag-label">Tag:</span>
    <button class="tag-btn tag-learning" id="fc-tag-learning" onclick="tagFlashcard('learning')">Learning</button>
    <button class="tag-btn tag-learned" id="fc-tag-learned" onclick="tagFlashcard('learned')">Learned</button>
    <button class="tag-btn tag-confused" id="fc-tag-confused" onclick="tagFlashcard('confused')">Confused</button>
    <button class="tag-btn tag-hard" id="fc-tag-hard" onclick="tagFlashcard('hard')">Hard</button>
  </div>

  <div class="flashcard-actions">
    <button class="btn btn-danger" id="dont-know-btn" onclick="markCard(false)">Still Learning</button>
    <button class="btn btn-success" id="know-btn" onclick="markCard(true)">Got It!</button>
  </div>

  <div class="progress-bar-container">
    <div class="progress-bar" id="progress-bar"></div>
  </div>
</section>

<!-- LIST VIEW -->
<section id="list-view" class="view">
  <div class="list-toolbar">
    <div class="search-bar">
      <input type="text" id="search-input" placeholder="Search words or meanings..." autocomplete="off">
    </div>
    <div class="filter-bar">
      <button class="filter-btn active" data-filter="all">All <span id="count-all" class="filter-count">0</span></button>
      <button class="filter-btn" data-filter="learning">Learning <span id="count-learning" class="filter-count">0</span></button>
      <button class="filter-btn" data-filter="learned">Learned <span id="count-learned" class="filter-count">0</span></button>
      <button class="filter-btn" data-filter="confused">Confused <span id="count-confused" class="filter-count">0</span></button>
      <button class="filter-btn" data-filter="hard">Hard <span id="count-hard" class="filter-count">0</span></button>
      <button class="filter-btn" data-filter="unmarked">Unmarked <span id="count-unmarked" class="filter-count">0</span></button>
    </div>
    <div class="list-actions">
      <div class="list-actions-left">
        <select id="sort-select" class="action-select" onchange="sortWords(this.value)">
          <option value="default">Default Order</option>
          <option value="alpha">A &rarr; Z</option>
          <option value="learning">Learning First</option>
          <option value="learned">Learned First</option>
          <option value="confused">Confused First</option>
          <option value="hard">Hard First</option>
        </select>
        <button class="action-btn" id="shuffle-btn" onclick="shuffleWords()">Shuffle</button>
      </div>
      <div class="list-actions-right">
        <button class="action-btn" id="compact-toggle" onclick="toggleCompact()">Compact</button>
      </div>
    </div>
  </div>
  <div class="word-list" id="word-list"></div>
</section>

<!-- CONCEPT GROUPS VIEW -->
<section id="concepts-view" class="view">
  <div class="concepts-header">
    <h2 class="concepts-title">GRE Vocabulary - Concept Groups with Bengali</h2>
    <div class="concepts-search-bar">
      <input type="text" id="concepts-search" placeholder="Search groups or words..." autocomplete="off">
    </div>
    <div class="concepts-stats" id="concepts-stats"></div>
    <button class="concepts-lookalike-link" onclick="switchToLookalikes()">Look-alikes &rarr;</button>
  </div>
  <div class="concepts-container" id="concepts-container"></div>
</section>

<!-- LOOK-ALIKES VIEW -->
<section id="lookalikes-view" class="view">
  <div class="lookalikes-header">
    <h2 class="lookalikes-title">Look-alike Words</h2>
    <p class="lookalikes-subtitle">Words that look almost the same but mean very different things</p>
    <div class="lookalikes-search-bar">
      <input type="text" id="lookalikes-search" placeholder="Search look-alike words..." autocomplete="off">
    </div>
    <div class="lookalikes-stats" id="lookalikes-stats"></div>
  </div>
  <div class="lookalikes-container" id="lookalikes-container"></div>
</section>

<!-- MATH VIEW -->
<!-- SLEEP-TIME WORDS -->
<section id="sleep-view" class="view">
  <div class="sleep-container">
    <div class="sleep-header">
      <div class="sleep-icon">
        <svg viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"/></svg>
      </div>
      <h2 class="sleep-title">Sleep-time Words</h2>
      <p class="sleep-subtitle">Pick a category, close your eyes, and let the words sink in</p>
    </div>

    <div class="sleep-filters">
      <button class="sleep-filter-btn" data-sleep-filter="all">All</button>
      <button class="sleep-filter-btn sleep-filter-learning" data-sleep-filter="learning">Learning</button>
      <button class="sleep-filter-btn sleep-filter-learned" data-sleep-filter="learned">Learned</button>
      <button class="sleep-filter-btn sleep-filter-confused" data-sleep-filter="confused">Confused</button>
      <button class="sleep-filter-btn sleep-filter-hard" data-sleep-filter="hard">Hard</button>
      <button class="sleep-filter-btn" data-sleep-filter="unmarked">Unmarked</button>
    </div>

    <div class="sleep-player" id="sleep-player" style="display:none">
      <div class="sleep-now-playing">
        <div class="sleep-word-num" id="sleep-word-num">1 / 20</div>
        <div class="sleep-word" id="sleep-word">acquiesce</div>
        <div class="sleep-meaning" id="sleep-meaning">to accept something reluctantly but without protest</div>
        <div class="sleep-example" id="sleep-example"></div>
      </div>

      <div class="sleep-progress-bar">
        <div class="sleep-progress-fill" id="sleep-progress"></div>
      </div>

      <div class="sleep-controls">
        <button class="sleep-ctrl-btn" id="sleep-prev" title="Previous">
          <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/></svg>
        </button>
        <button class="sleep-ctrl-btn sleep-play-btn" id="sleep-play" title="Pause">
          <svg class="sleep-icon-pause" viewBox="0 0 24 24" width="28" height="28" fill="currentColor"><path d="M6 19h4V5H6zm8-14v14h4V5z"/></svg>
          <svg class="sleep-icon-play" viewBox="0 0 24 24" width="28" height="28" fill="currentColor" style="display:none"><path d="M8 5v14l11-7z"/></svg>
        </button>
        <button class="sleep-ctrl-btn" id="sleep-next" title="Next">
          <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6z"/></svg>
        </button>
        <button class="sleep-ctrl-btn" id="sleep-stop" title="Stop">
          <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor"><rect x="6" y="6" width="12" height="12" rx="2"/></svg>
        </button>
      </div>
    </div>
  </div>
</section>

<section id="math-view" class="view">
  <div class="math-header">
    <h2 class="math-title">GRE Quantitative Reasoning</h2>
    <div class="math-chapter-tabs" id="math-chapter-tabs"></div>
    <div class="math-toolbar">
      <div class="math-search-bar">
        <input type="text" id="math-search" placeholder="Search topics..." autocomplete="off">
      </div>
      <div class="math-toolbar-actions">
        <button class="math-toolbar-btn" onclick="toggleAllMathTopics(true)">Expand All</button>
        <button class="math-toolbar-btn" onclick="toggleAllMathTopics(false)">Collapse All</button>
        <button class="math-toolbar-btn" id="math-show-answers-btn" onclick="toggleAllMathAnswers()">Show Answers</button>
      </div>
    </div>
    <div class="math-progress-bar-wrap">
      <div class="math-progress-bar" id="math-progress-bar"></div>
    </div>
    <div class="math-progress-summary" id="math-progress-summary"></div>
  </div>
  <div class="math-content" id="math-content"></div>
</section>

<script>
// --- Hero ---
function enterApp() {
  const hero = document.getElementById('hero');
  hero.classList.add('hero-exiting');
  setTimeout(() => {
    document.body.classList.add('app-mode');
    sessionStorage.setItem('greHeroSeen', '1');
    loadDeck();
  }, 450);
}

// Count-up animation for hero stats
function animateCounters() {
  document.querySelectorAll('.hero-stat-number[data-target]').forEach(el => {
    const target = parseInt(el.dataset.target, 10);
    if (!target) return;
    const duration = 1200;
    const start = performance.now();
    function tick(now) {
      const progress = Math.min((now - start) / duration, 1);
      const eased = 1 - Math.pow(1 - progress, 3);
      el.textContent = Math.round(target * eased);
      if (progress < 1) requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  });
}

// CTA button with ripple effect
document.getElementById('hero-cta').addEventListener('click', function(e) {
  const rect = this.getBoundingClientRect();
  const ripple = document.createElement('span');
  ripple.className = 'ripple';
  ripple.style.left = (e.clientX - rect.left) + 'px';
  ripple.style.top = (e.clientY - rect.top) + 'px';
  this.appendChild(ripple);
  setTimeout(() => ripple.remove(), 600);
  enterApp();
});

// Hero feature cards — click to enter app at specific view
document.querySelectorAll('.hero-feature[data-target]').forEach(card => {
  card.addEventListener('click', () => {
    const target = card.dataset.target;
    enterApp();
    // After enterApp's setTimeout fires, switch to the target view
    setTimeout(() => {
      document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
      document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
      const btn = document.querySelector(`.nav-btn[data-view="${target}"]`);
      if (btn) btn.classList.add('active');
      document.getElementById(target + '-view').classList.add('active');
      if (target === 'list') loadWordList();
      if (target === 'concepts' && !conceptsLoaded) loadConceptGroups();
      if (target === 'math' && !mathLoaded) {
        renderMathChapterTabs();
        renderMathContent();
        mathLoaded = true;
      }
      if (target === 'verbal-practice') {
        window.location.href = '/verbal/practice';
        return;
      }
    }, 460);
  });
  card.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); card.click(); }
  });
});

// Skip hero if already seen this session
if (sessionStorage.getItem('greHeroSeen')) {
  document.body.classList.add('app-mode');
} else {
  animateCounters();
}

// --- Theme ---
const svgSun = '<svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>';
const svgMoon = '<svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>';

function updateThemeIcon(theme) {
  document.getElementById('theme-toggle').innerHTML = theme === 'dark' ? svgSun : svgMoon;
}

const savedTheme = localStorage.getItem('greTheme') || 'dark';
document.documentElement.setAttribute('data-theme', savedTheme);
updateThemeIcon(savedTheme);

document.getElementById('theme-toggle').addEventListener('click', () => {
  const btn = document.getElementById('theme-toggle');
  const current = document.documentElement.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  btn.style.transform = 'rotate(360deg) scale(0.8)';
  setTimeout(() => { btn.style.transform = ''; }, 400);
  document.documentElement.setAttribute('data-theme', next);
  localStorage.setItem('greTheme', next);
  updateThemeIcon(next);
});

// --- State ---
let deck = [];
let currentIndex = 0;
let known = new Set();
let learning = new Set();
let allWords = [];

// Shared word cache — fetch once, reuse everywhere
let _wordsCache = null;
async function fetchWords() {
  if (_wordsCache) return _wordsCache;
  const res = await fetch('/api/words');
  if (!res.ok) throw new Error(`API error: ${res.status}`);
  _wordsCache = await res.json();
  return _wordsCache;
}

function saveDeckState() {
  sessionStorage.setItem('greDeck', JSON.stringify({
    words: deck.map(w => w.word),
    index: currentIndex,
    known: [...known],
    learning: [...learning],
    filter: document.getElementById('deck-filter').value,
    batch: document.getElementById('batch-size').value
  }));
}

function restoreDeck(wordPool) {
  try {
    const saved = JSON.parse(sessionStorage.getItem('greDeck'));
    if (!saved || !saved.words || saved.words.length === 0) return false;
    // Restore filter & batch UI
    document.getElementById('deck-filter').value = saved.filter || 'all';
    document.getElementById('batch-size').value = saved.batch || '20';
    // Rebuild deck from saved word order
    const wordMap = {};
    wordPool.forEach(w => wordMap[w.word] = w);
    deck = saved.words.map(name => wordMap[name]).filter(Boolean);
    if (deck.length === 0) return false;
    currentIndex = Math.min(saved.index || 0, deck.length - 1);
    known = new Set(saved.known || []);
    learning = new Set(saved.learning || []);
    showCard();
    updateStats();
    return true;
  } catch { return false; }
}

// --- Navigation ---
document.querySelectorAll('.nav-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
    btn.classList.add('active');
    document.getElementById(btn.dataset.view + '-view').classList.add('active');
    if (btn.dataset.view === 'list') {
      if (allWords.length === 0) loadWordList();
      else renderWordList();
    }
    if (btn.dataset.view === 'concepts') {
      if (!conceptsLoaded) loadConceptGroups();
      else renderConceptGroups(document.getElementById('concepts-search')?.value || '');
    }
    if (btn.dataset.view === 'flashcard' && deck.length > 0) updateFlashcardTags();
    if (btn.dataset.view !== 'sleep' && typeof stopSleepAudio === 'function') stopSleepAudio();
    if (btn.dataset.view === 'math' && !mathLoaded) {
      renderMathChapterTabs();
      renderMathContent();
      mathLoaded = true;
    }
    if (btn.dataset.view === 'lookalikes') {
      if (!lookalikesLoaded) loadLookalikes();
    }
  });
});

// --- Flashcard Logic ---
async function loadDeck() {
  const btn = document.getElementById('new-deck-btn');
  const filter = document.getElementById('deck-filter').value;
  const batchVal = document.getElementById('batch-size').value;

  btn.disabled = true;
  btn.textContent = 'Loading...';

  try {
    let pool = [...await fetchWords()];

    if (filter !== 'all') {
      if (filter === 'unmarked') {
        pool = pool.filter(w => !wordTags[w.word]);
      } else {
        pool = pool.filter(w => wordTags[w.word] === filter);
      }
    }

    if (pool.length === 0) {
      deck = [];
      currentIndex = 0;
      known = new Set();
      learning = new Set();
      document.getElementById('card-word').textContent = 'No words found';
      document.querySelector('.card-hint').textContent = `No ${filter === 'all' ? '' : filter + ' '}words to study`;
      document.getElementById('card-counter').textContent = '0 / 0';
      document.getElementById('progress-bar').style.width = '0%';
      updateFlashcardTags();
      return;
    }

    const count = batchVal === 'all' ? pool.length : Math.min(parseInt(batchVal), pool.length);

    // Shuffle and pick
    for (let i = pool.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [pool[i], pool[j]] = [pool[j], pool[i]];
    }
    deck = pool.slice(0, count);

    currentIndex = 0;
    known = new Set();
    learning = new Set();
    showCard();
    updateStats();
    saveDeckState();
  } catch (e) {
    console.error('loadDeck error:', e);
    document.getElementById('card-word').textContent = 'Connection error';
    document.querySelector('.card-hint').textContent = 'Check your connection and try again';
  } finally {
    btn.disabled = false;
    btn.textContent = 'New Deck';
  }
}

let lastDirection = 'right';

function showCard() {
  if (deck.length === 0) return;
  const card = deck[currentIndex];
  const fc = document.getElementById('flashcard');
  fc.classList.remove('flipped');

  // Slide animation
  fc.classList.remove('slide-right', 'slide-left');
  void fc.offsetWidth; // force reflow
  fc.classList.add(lastDirection === 'right' ? 'slide-right' : 'slide-left');

  document.getElementById('card-word').textContent = card.word;
  if (card.memory_hook) {
    document.getElementById('card-hook').textContent = card.memory_hook;
    document.getElementById('card-hook-section').style.display = '';
  } else {
    document.getElementById('card-hook-section').style.display = 'none';
  }
  document.getElementById('card-meaning').textContent = card.meaning;
  document.getElementById('card-usage').textContent = card.usage;
  document.getElementById('card-not-used').textContent = card.not_used_for;
  document.getElementById('card-example').textContent = card.example;
  document.getElementById('card-counter').textContent = `${currentIndex + 1} / ${deck.length}`;

  document.getElementById('prev-btn').disabled = currentIndex === 0;
  document.getElementById('next-btn').disabled = currentIndex === deck.length - 1;

  // Deck progress bar (position in deck)
  const deckPct = ((currentIndex + 1) / deck.length * 100);
  document.getElementById('deck-progress').style.width = deckPct + '%';

  const pct = ((known.size + learning.size) / deck.length) * 100;
  document.getElementById('progress-bar').style.width = pct + '%';

  updateFlashcardTags();
}

function flipCard() {
  document.getElementById('flashcard').classList.toggle('flipped');
}

/* Voice / TTS */
let ttsAudio = null;

async function speakCard() {
  if (deck.length === 0) return;
  const btn = document.getElementById('voice-btn');
  const card = deck[currentIndex];

  // If already playing, stop
  if (ttsAudio && !ttsAudio.paused) {
    ttsAudio.pause();
    ttsAudio = null;
    btn.classList.remove('playing');
    return;
  }

  const text = `${card.word} ... ${card.word} ... It means: ${card.meaning} ... You would use it to describe: ${card.usage} ... For example: ${card.example}`;

  btn.classList.add('loading');
  try {
    const res = await fetch('/api/tts', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text })
    });
    if (!res.ok) throw new Error('TTS failed');

    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    ttsAudio = new Audio(url);
    btn.classList.remove('loading');
    btn.classList.add('playing');
    ttsAudio.play();
    ttsAudio.onended = () => {
      btn.classList.remove('playing');
      URL.revokeObjectURL(url);
      ttsAudio = null;
    };
  } catch (e) {
    btn.classList.remove('loading');
    console.error('TTS error:', e);
  }
}

function markCard(isKnown) {
  const word = deck[currentIndex].word;
  const fc = document.getElementById('flashcard');

  // Flash animation
  fc.classList.remove('flash-green', 'flash-red');
  void fc.offsetWidth;
  fc.classList.add(isKnown ? 'flash-green' : 'flash-red');

  if (isKnown) {
    known.add(word);
    learning.delete(word);
  } else {
    learning.add(word);
    known.delete(word);
  }

  // Persist as tag so it shows in Word List & other views
  const newTag = isKnown ? 'learned' : 'learning';
  if (wordTags[word] !== newTag) {
    wordTags[word] = newTag;
    saveTags();
  }

  updateStats();

  // Badge pop animation
  const badge = document.getElementById(isKnown ? 'known-count' : 'unknown-count');
  badge.classList.remove('pop');
  void badge.offsetWidth;
  badge.classList.add('pop');

  lastDirection = 'right';
  if (currentIndex < deck.length - 1) {
    setTimeout(() => { currentIndex++; showCard(); saveDeckState(); }, 200);
  } else {
    setTimeout(() => showSummary(), 200);
  }
}

function showSummary() {
  showCard();
  const total = deck.length;
  const pct = Math.round((known.size / total) * 100);
  document.getElementById('card-word').textContent = `Done! ${known.size}/${total} (${pct}%)`;
  document.getElementById('flashcard').classList.remove('flipped');
  document.querySelector('.card-hint').textContent = 'Click "New Deck" to continue';
}

function updateStats() {
  document.getElementById('known-count').textContent = `${known.size} Known`;
  document.getElementById('unknown-count').textContent = `${learning.size} Learning`;
}

function tagFlashcard(tag) {
  if (deck.length === 0) return;
  const word = deck[currentIndex].word;
  if (wordTags[word] === tag) {
    delete wordTags[word];
  } else {
    wordTags[word] = tag;
  }
  saveTags();
  updateFlashcardTags();
  if (!currentUser && !syncBannerShown) showSyncBanner();
}

function updateFlashcardTags() {
  const word = deck.length > 0 ? deck[currentIndex].word : null;
  const tag = word ? (wordTags[word] || '') : '';
  ['learning', 'learned', 'confused', 'hard'].forEach(t => {
    const btn = document.getElementById('fc-tag-' + t);
    btn.classList.toggle('active', tag === t);
  });
}

document.getElementById('prev-btn').addEventListener('click', () => {
  if (currentIndex > 0) { lastDirection = 'left'; currentIndex--; showCard(); saveDeckState(); }
});
document.getElementById('next-btn').addEventListener('click', () => {
  if (currentIndex < deck.length - 1) { lastDirection = 'right'; currentIndex++; showCard(); saveDeckState(); }
});
document.getElementById('new-deck-btn').addEventListener('click', loadDeck);

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (document.activeElement.tagName === 'INPUT') return;
  if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); flipCard(); }
  if (e.key === 'ArrowLeft') { if (currentIndex > 0) { lastDirection = 'left'; currentIndex--; showCard(); saveDeckState(); } }
  if (e.key === 'ArrowRight') { markCard(true); }
  if (e.key === 'ArrowDown') { markCard(false); }
});

// --- Swipe gestures for flashcards ---
(function() {
  const area = document.querySelector('.flashcard-area');
  let startX, startY, startTime;
  area.addEventListener('touchstart', function(e) {
    const t = e.changedTouches[0];
    startX = t.clientX;
    startY = t.clientY;
    startTime = Date.now();
  }, { passive: true });
  area.addEventListener('touchend', function(e) {
    if (!startX) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - startX;
    const dy = t.clientY - startY;
    const elapsed = Date.now() - startTime;
    startX = null;
    if (elapsed > 500) return;
    if (Math.abs(dx) < 50) return;
    if (Math.abs(dy) > Math.abs(dx)) return;
    if (dx < 0 && currentIndex < deck.length - 1) {
      lastDirection = 'right'; currentIndex++; showCard();
    } else if (dx > 0 && currentIndex > 0) {
      lastDirection = 'left'; currentIndex--; showCard();
    }
  }, { passive: true });
})();

// --- Word List ---
let searchTimeout;
let wordTags = JSON.parse(localStorage.getItem('greWordTags') || '{}');
let activeFilter = 'all';
let compactMode = false;
let originalWords = [];

let currentUser = null;
let syncTimeout = null;
let syncBannerShown = false;

function saveTags() {
  localStorage.setItem('greWordTags', JSON.stringify(wordTags));
  if (currentUser) {
    clearTimeout(syncTimeout);
    syncTimeout = setTimeout(() => pushProgress(), 500);
  }
}

async function loadWordList(q = '') {
  const list = document.getElementById('word-list');
  list.innerHTML = '<div class="empty-state">Loading words...</div>';
  try {
    if (q) {
      const res = await fetch(`/api/words?q=${encodeURIComponent(q)}`);
      allWords = await res.json();
    } else {
      allWords = [...await fetchWords()];
    }
    originalWords = [...allWords];
    // Auto-compact on mobile for performance (716 full rows = ~12k DOM nodes)
    if (window.innerWidth <= 640 && !compactMode && allWords.length > 100) {
      compactMode = true;
      const btn = document.getElementById('compact-toggle');
      if (btn) { btn.textContent = 'Full View'; btn.classList.add('active'); }
    }
    document.getElementById('sort-select').value = 'default';
    renderWordList();
  } catch (e) {
    console.error('loadWordList error:', e);
    list.innerHTML = '<div class="empty-state">Failed to load words. Check your connection and try again.</div>';
  }
}

function getFilteredWords() {
  if (activeFilter === 'all') return allWords;
  if (activeFilter === 'unmarked') return allWords.filter(w => !wordTags[w.word]);
  return allWords.filter(w => wordTags[w.word] === activeFilter);
}

function updateFilterCounts() {
  const counts = { all: allWords.length, learning: 0, learned: 0, confused: 0, hard: 0, unmarked: 0 };
  allWords.forEach(w => {
    const tag = wordTags[w.word];
    if (tag) counts[tag] = (counts[tag] || 0) + 1;
    else counts.unmarked++;
  });
  document.getElementById('count-all').textContent = counts.all;
  document.getElementById('count-learning').textContent = counts.learning;
  document.getElementById('count-learned').textContent = counts.learned;
  document.getElementById('count-confused').textContent = counts.confused;
  document.getElementById('count-hard').textContent = counts.hard;
  document.getElementById('count-unmarked').textContent = counts.unmarked;
}

function toggleTag(word, tag) {
  if (wordTags[word] === tag) {
    delete wordTags[word];
  } else {
    wordTags[word] = tag;
  }
  saveTags();
  renderWordList();
}

/* Compact-mode hover popover */
let chipPopover = null;
let chipPopoverTimeout = null;

function getOrCreatePopover() {
  if (!chipPopover) {
    chipPopover = document.createElement('div');
    chipPopover.className = 'chip-popover';
    document.body.appendChild(chipPopover);
    chipPopover.addEventListener('mouseenter', () => clearTimeout(chipPopoverTimeout));
    chipPopover.addEventListener('mouseleave', hideChipPopover);
  }
  return chipPopover;
}

function showChipPopover(chip) {
  clearTimeout(chipPopoverTimeout);
  const wordName = chip.dataset.word;
  const w = allWords.find(x => x.word === wordName);
  if (!w) return;

  const pop = getOrCreatePopover();
  const tag = wordTags[w.word] || '';
  const esc = w.word.replace(/'/g, "\\'");
  pop.innerHTML = `
    <div class="chip-popover-word">${w.word}</div>
    <div class="chip-popover-meaning">${w.meaning}</div>
    ${w.memory_hook ? `<div class="chip-popover-hook">\u{1f4a1} ${w.memory_hook}</div>` : ''}
    <div class="chip-popover-example">"${w.example}"</div>
    <div class="chip-popover-tags">
      <button class="tag-btn tag-learning ${tag === 'learning' ? 'active' : ''}" onclick="popoverTag('${esc}','learning')" title="Learning">&#9733;</button>
      <button class="tag-btn tag-learned ${tag === 'learned' ? 'active' : ''}" onclick="popoverTag('${esc}','learned')" title="Learned">L</button>
      <button class="tag-btn tag-confused ${tag === 'confused' ? 'active' : ''}" onclick="popoverTag('${esc}','confused')" title="Confused">C</button>
      <button class="tag-btn tag-hard ${tag === 'hard' ? 'active' : ''}" onclick="popoverTag('${esc}','hard')" title="Hard">H</button>
    </div>`;

  // Position relative to chip
  const rect = chip.getBoundingClientRect();
  pop.style.left = rect.left + 'px';
  pop.style.top = (rect.bottom + 8) + 'px';

  // Adjust if overflowing right
  const popW = 320;
  if (rect.left + popW > window.innerWidth - 16) {
    pop.style.left = Math.max(16, window.innerWidth - popW - 16) + 'px';
  }
  // Adjust if overflowing bottom
  pop.classList.add('visible');
  requestAnimationFrame(() => {
    const popRect = pop.getBoundingClientRect();
    if (popRect.bottom > window.innerHeight - 16) {
      pop.style.top = (rect.top - popRect.height - 8) + 'px';
    }
  });
}

function hideChipPopover() {
  chipPopoverTimeout = setTimeout(() => {
    if (chipPopover) chipPopover.classList.remove('visible');
  }, 150);
}

function popoverTag(word, tag) {
  toggleTag(word, tag);
  // Re-render popover with updated tag
  const chip = document.querySelector(`.word-chip[data-word="${word}"]`);
  if (chip) showChipPopover(chip);
}

function initChipPopovers() {
  document.querySelectorAll('.word-chip').forEach(chip => {
    chip.addEventListener('mouseenter', () => showChipPopover(chip));
    chip.addEventListener('mouseleave', hideChipPopover);
  });
}

function renderWordList() {
  updateFilterCounts();
  const words = getFilteredWords();
  const list = document.getElementById('word-list');
  if (words.length === 0) {
    list.innerHTML = '<div class="empty-state">No words found</div>';
    list.classList.remove('compact');
    return;
  }

  if (compactMode) {
    list.classList.add('compact');
    list.innerHTML = words.map(w => {
      const tag = wordTags[w.word] || '';
      return `<div class="word-chip ${tag ? 'chip-' + tag : ''}" data-word="${w.word}">${w.word}</div>`;
    }).join('');
    initChipPopovers();
  } else {
    list.classList.remove('compact');
    list.innerHTML = words.map((w, i) => {
      const tag = wordTags[w.word] || '';
      const globalIndex = allWords.indexOf(w) + 1;
      return `
      <div class="word-row ${tag ? 'tagged-' + tag : ''}">
        <div class="word-row-num">${globalIndex}</div>
        <div class="word-row-content">
          <div class="word-row-header">
            <div class="word-row-title">${w.word}</div>
            <div class="word-row-toggles">
              <button class="tag-btn tag-learning ${tag === 'learning' ? 'active' : ''}" onclick="toggleTag('${w.word}', 'learning')">Learning</button>
              <button class="tag-btn tag-learned ${tag === 'learned' ? 'active' : ''}" onclick="toggleTag('${w.word}', 'learned')">Learned</button>
              <button class="tag-btn tag-confused ${tag === 'confused' ? 'active' : ''}" onclick="toggleTag('${w.word}', 'confused')">Confused</button>
              <button class="tag-btn tag-hard ${tag === 'hard' ? 'active' : ''}" onclick="toggleTag('${w.word}', 'hard')">Hard</button>
            </div>
          </div>
          <div class="word-row-meaning">${w.meaning}</div>
          ${w.memory_hook ? `<div class="word-row-hook"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" style="vertical-align:-2px"><path d="M12 2a7 7 0 0 1 7 7c0 3-2.5 5-5 6.5S12 18 12 22"/><path d="M12 2a7 7 0 0 0-7 7c0 3 2.5 5 5 6.5S12 18 12 22"/><line x1="2" y1="12" x2="22" y2="12" stroke-width="1.5" opacity="0.5"/></svg> ${w.memory_hook}</div>` : ''}
          <div class="word-row-details">
            <span><span class="meta-label">Use:</span> ${w.usage}</span>
            <span class="not-for"><span class="meta-label">Not for:</span> ${w.not_used_for}</span>
          </div>
          <div class="word-row-example">"${w.example}"</div>
        </div>
      </div>`;
    }).join('');
  }
}

function toggleCompact() {
  compactMode = !compactMode;
  const btn = document.getElementById('compact-toggle');
  btn.textContent = compactMode ? 'Full View' : 'Compact';
  btn.classList.toggle('active', compactMode);
  renderWordList();
}

function shuffleWords() {
  for (let i = allWords.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [allWords[i], allWords[j]] = [allWords[j], allWords[i]];
  }
  document.getElementById('sort-select').value = 'default';
  renderWordList();
}

function sortWords(mode) {
  if (mode === 'default') {
    allWords = [...originalWords];
  } else if (mode === 'alpha') {
    allWords.sort((a, b) => a.word.localeCompare(b.word));
  } else {
    // learned, confused, hard - put matching tag first
    allWords.sort((a, b) => {
      const aMatch = wordTags[a.word] === mode ? 0 : 1;
      const bMatch = wordTags[b.word] === mode ? 0 : 1;
      return aMatch - bMatch;
    });
  }
  renderWordList();
}

// Filter buttons
document.querySelectorAll('.filter-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    activeFilter = btn.dataset.filter;
    renderWordList();
  });
});

document.getElementById('search-input').addEventListener('input', (e) => {
  clearTimeout(searchTimeout);
  searchTimeout = setTimeout(() => loadWordList(e.target.value), 300);
});

// --- Concept Groups ---
let conceptsLoaded = false;
let conceptData = {};
let collapsedGroups = JSON.parse(localStorage.getItem('greCollapsedGroups') || '{}');

async function loadConceptGroups() {
  const res = await fetch('/api/concept-groups');
  conceptData = await res.json();
  conceptsLoaded = true;
  renderConceptGroups();
}

function renderConceptGroups(filter = '') {
  const container = document.getElementById('concepts-container');
  const groups = Object.entries(conceptData);
  const q = filter.toLowerCase();

  let totalGroups = 0;
  let totalWords = 0;
  let html = '';

  groups.forEach(([groupName, words]) => {
    const wordEntries = Object.entries(words);
    let filtered = wordEntries;
    if (q) {
      filtered = wordEntries.filter(([word, info]) =>
        word.toLowerCase().includes(q) ||
        info.meaning.toLowerCase().includes(q) ||
        info.bengali.includes(q) ||
        groupName.toLowerCase().includes(q)
      );
      if (filtered.length === 0) return;
    }

    totalGroups++;
    totalWords += filtered.length;
    const isCollapsed = collapsedGroups[groupName] && !q;

    html += `
    <div class="concept-group">
      <div class="concept-group-header" onclick="toggleGroup(this, '${groupName.replace(/'/g, "\\'")}')">
        <div class="concept-group-title">
          <span class="collapse-icon">${isCollapsed ? '+' : '-'}</span>
          ${groupName}
        </div>
        <span class="concept-group-count">${filtered.length} words</span>
      </div>
      <div class="concept-group-body" style="${isCollapsed ? 'display:none' : ''}">
        <table class="concept-table">
          <thead>
            <tr>
              <th class="col-num">#</th>
              <th class="col-word">Word</th>
              <th class="col-meaning">Meaning</th>
              <th class="col-bengali">Bengali (বাংলা)</th>
              <th class="col-tag">Tag</th>
            </tr>
          </thead>
          <tbody>
            ${filtered.map(([word, info], i) => {
              const wTag = wordTags[word] || '';
              return `
            <tr class="${wTag ? 'concept-tagged-' + wTag : ''}">
              <td class="col-num">${i + 1}</td>
              <td class="col-word">${word}</td>
              <td class="col-meaning">${info.meaning}</td>
              <td class="col-bengali">${info.bengali}</td>
              <td class="col-tag">
                <div class="concept-tag-btns">
                  <button class="ctag-btn ctag-learning ${wTag === 'learning' ? 'active' : ''}" onclick="tagConceptWord('${word.replace(/'/g, "\\'")}', 'learning')" title="Learning">&#9733;</button>
                  <button class="ctag-btn ctag-learned ${wTag === 'learned' ? 'active' : ''}" onclick="tagConceptWord('${word.replace(/'/g, "\\'")}', 'learned')" title="Learned">L</button>
                  <button class="ctag-btn ctag-confused ${wTag === 'confused' ? 'active' : ''}" onclick="tagConceptWord('${word.replace(/'/g, "\\'")}', 'confused')" title="Confused">C</button>
                  <button class="ctag-btn ctag-hard ${wTag === 'hard' ? 'active' : ''}" onclick="tagConceptWord('${word.replace(/'/g, "\\'")}', 'hard')" title="Hard">H</button>
                </div>
              </td>
            </tr>`}).join('')}
          </tbody>
        </table>
      </div>
    </div>`;
  });

  container.innerHTML = html || '<div class="empty-state">No matching groups found</div>';
  document.getElementById('concepts-stats').textContent = `${totalGroups} groups \u00B7 ${totalWords} words`;
}

function tagConceptWord(word, tag) {
  if (wordTags[word] === tag) {
    delete wordTags[word];
  } else {
    wordTags[word] = tag;
  }
  saveTags();
  // Re-render concept groups with current search filter
  const searchVal = document.getElementById('concepts-search').value || '';
  renderConceptGroups(searchVal);
  if (!currentUser && !syncBannerShown) showSyncBanner();
}

function toggleGroup(header, groupName) {
  const body = header.nextElementSibling;
  const icon = header.querySelector('.collapse-icon');
  if (body.style.display === 'none') {
    body.style.display = '';
    body.style.overflow = 'hidden';
    body.style.maxHeight = '0';
    requestAnimationFrame(() => {
      body.style.transition = 'max-height 0.4s ease, opacity 0.3s ease';
      body.style.maxHeight = body.scrollHeight + 'px';
      body.style.opacity = '1';
    });
    setTimeout(() => { body.style.maxHeight = 'none'; body.style.overflow = ''; }, 450);
    icon.textContent = '-';
    delete collapsedGroups[groupName];
  } else {
    body.style.overflow = 'hidden';
    body.style.maxHeight = body.scrollHeight + 'px';
    requestAnimationFrame(() => {
      body.style.transition = 'max-height 0.35s ease, opacity 0.25s ease';
      body.style.maxHeight = '0';
      body.style.opacity = '0';
    });
    setTimeout(() => { body.style.display = 'none'; body.style.opacity = '1'; }, 350);
    icon.textContent = '+';
    collapsedGroups[groupName] = true;
  }
  localStorage.setItem('greCollapsedGroups', JSON.stringify(collapsedGroups));
}

let conceptSearchTimeout;
document.getElementById('concepts-search').addEventListener('input', (e) => {
  clearTimeout(conceptSearchTimeout);
  conceptSearchTimeout = setTimeout(() => renderConceptGroups(e.target.value), 300);
});

// --- Look-alikes ---
let lookalikesLoaded = false;
let lookalikesData = [];
let lookalikesCollapsed = JSON.parse(localStorage.getItem('greLookalikesCollapsed') || '{}');

function switchToLookalikes() {
  document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
  const btn = document.querySelector('.nav-btn[data-view="lookalikes"]');
  if (btn) btn.classList.add('active');
  document.getElementById('lookalikes-view').classList.add('active');
  if (!lookalikesLoaded) loadLookalikes();
}

async function loadLookalikes() {
  const res = await fetch('/api/lookalikes');
  lookalikesData = await res.json();
  lookalikesLoaded = true;
  renderLookalikes();
}

function renderLookalikes(filter = '') {
  const container = document.getElementById('lookalikes-container');
  const q = filter.toLowerCase();
  let totalGroups = 0;
  let totalWords = 0;
  let html = '';

  lookalikesData.forEach((group, gi) => {
    const words = group.words;
    if (q) {
      const match = words.some(w =>
        w.word.toLowerCase().includes(q) ||
        w.meaning.toLowerCase().includes(q)
      ) || group.title.toLowerCase().includes(q);
      if (!match) return;
    }

    totalGroups++;
    totalWords += words.length;
    const isCollapsed = lookalikesCollapsed[gi] && !q;

    html += `
    <div class="lookalike-group">
      <div class="lookalike-group-header" onclick="toggleLookalike(this, ${gi})">
        <div class="lookalike-group-title">
          <span class="collapse-icon">${isCollapsed ? '+' : '-'}</span>
          ${group.title}
        </div>
        <span class="lookalike-group-count">${words.length} words</span>
      </div>
      <div class="lookalike-group-body" style="${isCollapsed ? 'display:none' : ''}">
        <div class="lookalike-cards">
          ${words.map(w => {
            const wTag = wordTags[w.word] || '';
            return `
          <div class="lookalike-card ${wTag ? 'lookalike-tagged-' + wTag : ''}">
            <div class="lookalike-word">${w.word}</div>
            <div class="lookalike-meaning">${w.meaning}</div>
            <div class="lookalike-tag-btns">
              <button class="ctag-btn ctag-learning ${wTag === 'learning' ? 'active' : ''}" onclick="tagLookalike('${w.word.replace(/'/g, "\\'")}', 'learning')" title="Learning">&#9733;</button>
              <button class="ctag-btn ctag-learned ${wTag === 'learned' ? 'active' : ''}" onclick="tagLookalike('${w.word.replace(/'/g, "\\'")}', 'learned')" title="Learned">L</button>
              <button class="ctag-btn ctag-confused ${wTag === 'confused' ? 'active' : ''}" onclick="tagLookalike('${w.word.replace(/'/g, "\\'")}', 'confused')" title="Confused">C</button>
              <button class="ctag-btn ctag-hard ${wTag === 'hard' ? 'active' : ''}" onclick="tagLookalike('${w.word.replace(/'/g, "\\'")}', 'hard')" title="Hard">H</button>
            </div>
          </div>`;
          }).join('')}
        </div>
      </div>
    </div>`;
  });

  container.innerHTML = html || '<div class="empty-state">No matching look-alikes found</div>';
  document.getElementById('lookalikes-stats').textContent = `${totalGroups} groups \u00B7 ${totalWords} words`;
}

function tagLookalike(word, tag) {
  if (wordTags[word] === tag) {
    delete wordTags[word];
  } else {
    wordTags[word] = tag;
  }
  saveTags();
  const searchVal = document.getElementById('lookalikes-search').value || '';
  renderLookalikes(searchVal);
  if (!currentUser && !syncBannerShown) showSyncBanner();
}

function toggleLookalike(header, groupIndex) {
  const body = header.nextElementSibling;
  const icon = header.querySelector('.collapse-icon');
  if (body.style.display === 'none') {
    body.style.display = '';
    body.style.overflow = 'hidden';
    body.style.maxHeight = '0';
    requestAnimationFrame(() => {
      body.style.transition = 'max-height 0.4s ease, opacity 0.3s ease';
      body.style.maxHeight = body.scrollHeight + 'px';
      body.style.opacity = '1';
    });
    setTimeout(() => { body.style.maxHeight = 'none'; body.style.overflow = ''; }, 450);
    icon.textContent = '-';
    delete lookalikesCollapsed[groupIndex];
  } else {
    body.style.overflow = 'hidden';
    body.style.maxHeight = body.scrollHeight + 'px';
    requestAnimationFrame(() => {
      body.style.transition = 'max-height 0.35s ease, opacity 0.25s ease';
      body.style.maxHeight = '0';
      body.style.opacity = '0';
    });
    setTimeout(() => { body.style.display = 'none'; body.style.opacity = '1'; }, 350);
    icon.textContent = '+';
    lookalikesCollapsed[groupIndex] = true;
  }
  localStorage.setItem('greLookalikesCollapsed', JSON.stringify(lookalikesCollapsed));
}

let lookalikesSearchTimeout;
document.getElementById('lookalikes-search').addEventListener('input', (e) => {
  clearTimeout(lookalikesSearchTimeout);
  lookalikesSearchTimeout = setTimeout(() => renderLookalikes(e.target.value), 300);
});

// --- Auth & Sync ---
async function checkAuth() {
  try {
    const res = await fetch('/auth/me');
    const data = await res.json();
    currentUser = data.user;
    renderAuthUI();
    if (currentUser) syncProgress();
  } catch (e) {
    currentUser = null;
    renderAuthUI();
  }
}

function renderAuthUI() {
  const navSection = document.getElementById('auth-section');
  const heroSection = document.getElementById('hero-auth');

  if (!currentUser) {
    navSection.innerHTML = '<a href="/auth/google" class="sign-in-btn">Sign In</a>';
    if (heroSection) heroSection.innerHTML = '<a href="/auth/google" class="hero-sign-in">Sign in with Google to save progress</a>';
    return;
  }

  // Hero: show signed-in state
  if (heroSection) heroSection.innerHTML = `<div class="hero-signed-in">Signed in as <strong>${currentUser.name || currentUser.email}</strong></div>`;

  // Nav: avatar + dropdown
  const pic = currentUser.picture
    ? `<img src="${currentUser.picture}" alt="" class="user-avatar" referrerpolicy="no-referrer">`
    : `<div class="user-avatar user-avatar-placeholder">${currentUser.name ? currentUser.name[0].toUpperCase() : '?'}</div>`;
  navSection.innerHTML = `
    <div class="user-menu" id="user-menu">
      ${pic}
      <span class="user-name">${currentUser.name || currentUser.email}</span>
      <div class="user-dropdown" id="user-dropdown">
        <div class="user-dropdown-email">${currentUser.email}</div>
        <a href="/auth/logout" class="user-dropdown-item">Sign Out</a>
      </div>
    </div>`;
  document.getElementById('user-menu').addEventListener('click', (e) => {
    e.stopPropagation();
    document.getElementById('user-dropdown').classList.toggle('show');
  });
  document.addEventListener('click', () => {
    const dd = document.getElementById('user-dropdown');
    if (dd) dd.classList.remove('show');
  });
}

async function syncProgress() {
  try {
    const res = await fetch('/api/progress');
    const data = await res.json();
    const serverTags = data.tags || {};

    // Merge: local wins for conflicts, server fills gaps
    const localTags = { ...wordTags };
    const merged = { ...serverTags, ...localTags };

    wordTags = merged;
    localStorage.setItem('greWordTags', JSON.stringify(wordTags));

    // Push merged to server
    await pushProgress();

    // Re-render if word list is loaded
    if (allWords.length > 0) renderWordList();
  } catch (e) {
    // Silently fall back to localStorage
  }
}

async function pushProgress() {
  if (!currentUser) return;
  try {
    await fetch('/api/progress', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ tags: wordTags }),
    });
  } catch (e) {
    // Silently fail — localStorage still has the data
  }
}

function showSyncBanner() {
  if (syncBannerShown || currentUser) return;
  syncBannerShown = true;
  const banner = document.createElement('div');
  banner.className = 'sync-banner';
  banner.innerHTML = '<span>Sign in to save your progress across devices</span><a href="/auth/google" class="sync-banner-btn">Sign In</a><button class="sync-banner-close" onclick="this.parentElement.remove()"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>';
  document.body.appendChild(banner);
  setTimeout(() => banner.classList.add('show'), 10);
}

// Show banner on first tag when not logged in
const origToggleTag = toggleTag;
toggleTag = function(word, tag) {
  origToggleTag(word, tag);
  if (!currentUser && !syncBannerShown) showSyncBanner();
};

// --- Nav brand returns to hero ---
document.querySelector('.nav-brand').addEventListener('click', () => {
  document.body.classList.remove('app-mode');
  sessionStorage.removeItem('greHeroSeen');
  animateCounters();
});

// --- Init ---
// Wire up server-rendered user menu dropdown (if present)
const ssrMenu = document.getElementById('user-menu');
if (ssrMenu) {
  ssrMenu.addEventListener('click', (e) => {
    e.stopPropagation();
    document.getElementById('user-dropdown').classList.toggle('show');
  });
}
document.addEventListener('click', () => {
  const dd = document.getElementById('user-dropdown');
  if (dd) dd.classList.remove('show');
});

// --- Sleep-time Words ---
let sleepDeck = [];
let sleepIndex = 0;
let sleepPlaying = false;
let sleepAudio = null;
let sleepLoaded = false;

async function loadSleepWords(filter) {
  let pool = [...await fetchWords()];

  if (filter === 'unmarked') {
    pool = pool.filter(w => !wordTags[w.word]);
  } else if (filter !== 'all') {
    pool = pool.filter(w => wordTags[w.word] === filter);
  }

  if (pool.length === 0) {
    alert('No words found for this filter.');
    return;
  }

  // Shuffle
  for (let i = pool.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [pool[i], pool[j]] = [pool[j], pool[i]];
  }

  sleepDeck = pool;
  sleepIndex = 0;
  document.getElementById('sleep-player').style.display = '';
  sleepPlaying = true;
  updateSleepUI();
  playSleepWord();
}

function updateSleepUI() {
  if (sleepDeck.length === 0) return;
  const w = sleepDeck[sleepIndex];
  document.getElementById('sleep-word-num').textContent = `${sleepIndex + 1} / ${sleepDeck.length}`;
  document.getElementById('sleep-word').textContent = w.word;
  document.getElementById('sleep-meaning').textContent = w.meaning;
  document.getElementById('sleep-example').textContent = `"${w.example}"`;
  document.getElementById('sleep-progress').style.width = ((sleepIndex + 1) / sleepDeck.length * 100) + '%';

  // Play/pause icon
  document.querySelector('.sleep-icon-pause').style.display = sleepPlaying ? '' : 'none';
  document.querySelector('.sleep-icon-play').style.display = sleepPlaying ? 'none' : '';
}

let sleepNextBlob = null; // prefetched audio for next word

function sleepTtsText(w) {
  return `${w.word} ... ${w.word} ... It means: ${w.meaning} ... You would use it to describe: ${w.usage} ... For example: ${w.example}`;
}

async function fetchSleepAudio(text) {
  const res = await fetch('/api/tts', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ text })
  });
  if (!res.ok) throw new Error('TTS failed');
  return await res.blob();
}

function prefetchNextSleep() {
  sleepNextBlob = null;
  if (sleepIndex + 1 < sleepDeck.length) {
    const next = sleepDeck[sleepIndex + 1];
    fetchSleepAudio(sleepTtsText(next))
      .then(blob => { sleepNextBlob = blob; })
      .catch(() => { sleepNextBlob = null; });
  }
}

async function playSleepWord() {
  if (!sleepPlaying || sleepIndex >= sleepDeck.length) {
    sleepPlaying = false;
    updateSleepUI();
    return;
  }

  const w = sleepDeck[sleepIndex];
  updateSleepUI();

  try {
    // Use prefetched audio if available, otherwise fetch now
    let blob;
    if (sleepNextBlob && sleepIndex > 0) {
      blob = sleepNextBlob;
      sleepNextBlob = null;
    } else {
      blob = await fetchSleepAudio(sleepTtsText(w));
    }

    const url = URL.createObjectURL(blob);
    sleepAudio = new Audio(url);
    sleepAudio.play();

    // Start prefetching the next word immediately
    prefetchNextSleep();

    sleepAudio.onended = () => {
      URL.revokeObjectURL(url);
      sleepAudio = null;
      if (sleepPlaying && sleepIndex < sleepDeck.length - 1) {
        sleepIndex++;
        setTimeout(() => playSleepWord(), 500);
      } else {
        sleepPlaying = false;
        updateSleepUI();
      }
    };
  } catch (e) {
    console.error('Sleep TTS error:', e);
    sleepPlaying = false;
    updateSleepUI();
  }
}

function stopSleepAudio() {
  sleepPlaying = false;
  sleepNextBlob = null;
  if (sleepAudio) { sleepAudio.pause(); sleepAudio = null; }
  updateSleepUI();
}

// Filter buttons
document.querySelectorAll('.sleep-filter-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.sleep-filter-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    stopSleepAudio();
    loadSleepWords(btn.dataset.sleepFilter);
  });
});

// Player controls
document.getElementById('sleep-play').addEventListener('click', () => {
  if (sleepDeck.length === 0) return;
  if (sleepPlaying) {
    stopSleepAudio();
  } else {
    sleepPlaying = true;
    updateSleepUI();
    playSleepWord();
  }
});

document.getElementById('sleep-prev').addEventListener('click', () => {
  if (sleepIndex > 0) {
    stopSleepAudio();
    sleepIndex--;
    sleepPlaying = true;
    playSleepWord();
  }
});

document.getElementById('sleep-next').addEventListener('click', () => {
  if (sleepIndex < sleepDeck.length - 1) {
    stopSleepAudio();
    sleepIndex++;
    sleepPlaying = true;
    playSleepWord();
  }
});

document.getElementById('sleep-stop').addEventListener('click', () => {
  stopSleepAudio();
  document.getElementById('sleep-player').style.display = 'none';
});

// --- Math Section ---
let mathStudied = JSON.parse(localStorage.getItem('greMathStudied') || '{}');
let activeMathChapter = 'arithmetic';

function renderMathChapterTabs() {
  const tabs = document.getElementById('math-chapter-tabs');
  const activeChapter = MATH_DATA.find(c => c.id === activeMathChapter);
  if (activeChapter) {
    document.getElementById('math-view').style.setProperty('--math-active-color', activeChapter.color);
  }
  tabs.innerHTML = MATH_DATA.map(ch =>
    `<button class="math-chapter-tab ${ch.id === activeMathChapter ? 'active' : ''}" data-chapter="${ch.id}" style="--ch-color:${ch.color}">
      <span class="math-tab-emoji">${ch.emoji}</span> ${ch.title}
    </button>`
  ).join('');
  tabs.querySelectorAll('.math-chapter-tab').forEach(btn => {
    btn.addEventListener('click', () => {
      activeMathChapter = btn.dataset.chapter;
      renderMathChapterTabs();
      renderMathContent();
    });
  });
}

function renderMathContent() {
  const chapter = MATH_DATA.find(c => c.id === activeMathChapter);
  if (!chapter) return;
  const container = document.getElementById('math-content');

  const studiedCount = chapter.sections.filter(s => mathStudied[s.id]).length;
  const pct = chapter.sections.length ? Math.round((studiedCount / chapter.sections.length) * 100) : 0;
  document.getElementById('math-progress-bar').style.width = pct + '%';
  document.getElementById('math-progress-summary').textContent =
    `${studiedCount} / ${chapter.sections.length} topics studied`;

  container.innerHTML = chapter.sections.map(sec => {
    const studied = mathStudied[sec.id];
    return `
    <div class="math-topic ${studied ? 'math-topic-studied' : ''}" id="math-${sec.id}" data-title="${sec.title.toLowerCase()}">
      <div class="math-topic-header" onclick="toggleMathTopic('${sec.id}')">
        <div class="math-topic-title-row">
          <span class="math-collapse-icon">+</span>
          <span class="math-topic-title">${sec.title}</span>
        </div>
        <div class="math-topic-meta">
          <span class="math-topic-count">${sec.questions.length} Q</span>
          <button class="math-studied-btn ${studied ? 'active' : ''}" onclick="event.stopPropagation(); toggleMathStudied('${sec.id}')" title="${studied ? 'Studied' : 'Mark as studied'}">
            ${studied ? '&#10003; Studied' : 'Mark Studied'}
          </button>
        </div>
      </div>
      <div class="math-topic-body" style="display:none">
        ${sec.concepts.length ? `<div class="math-section-block math-concept-block">
          <div class="math-section-label">Key Concepts</div>
          <ul class="math-concept-list">${sec.concepts.map(c => `<li>${c}</li>`).join('')}</ul>
        </div>` : ''}
        ${sec.formulas.length ? `<div class="math-section-block math-formula-block">
          <div class="math-section-label">Formulas</div>
          <ul class="math-formula-list">${sec.formulas.map(f => `<li>${f}</li>`).join('')}</ul>
        </div>` : ''}
        ${sec.tips.length ? `<div class="math-section-block math-tips-block">
          <div class="math-section-label">Tips &amp; Traps</div>
          <ul class="math-tips-list">${sec.tips.map(t => `<li>${t}</li>`).join('')}</ul>
        </div>` : ''}
        ${sec.questions.length ? `<div class="math-section-block math-questions-block">
          <div class="math-section-label">Practice Questions</div>
          <div class="math-questions">${sec.questions.map((qa, i) => `
            <div class="math-qa">
              <div class="math-q" onclick="this.nextElementSibling.classList.toggle('show')">
                <span class="math-q-num">Q${i+1}</span> ${qa.q}
                <span class="math-reveal-hint">tap to reveal</span>
              </div>
              <div class="math-a"><span class="math-a-label">Answer:</span> ${qa.a}</div>
            </div>`).join('')}
          </div>
        </div>` : ''}
      </div>
    </div>`;
  }).join('');
}

function toggleMathTopic(secId) {
  const el = document.getElementById('math-' + secId);
  const body = el.querySelector('.math-topic-body');
  const icon = el.querySelector('.math-collapse-icon');
  if (body.style.display === 'none') {
    body.style.display = '';
    icon.textContent = '\u2212';
  } else {
    body.style.display = 'none';
    icon.textContent = '+';
  }
}

function toggleMathStudied(secId) {
  if (mathStudied[secId]) {
    delete mathStudied[secId];
  } else {
    mathStudied[secId] = true;
  }
  localStorage.setItem('greMathStudied', JSON.stringify(mathStudied));
  renderMathContent();
}

function toggleAllMathTopics(expand) {
  document.querySelectorAll('#math-content .math-topic').forEach(topic => {
    const body = topic.querySelector('.math-topic-body');
    const icon = topic.querySelector('.math-collapse-icon');
    if (expand) {
      body.style.display = '';
      icon.textContent = '\u2212';
    } else {
      body.style.display = 'none';
      icon.textContent = '+';
    }
  });
}

let mathAnswersShown = false;
function toggleAllMathAnswers() {
  mathAnswersShown = !mathAnswersShown;
  const btn = document.getElementById('math-show-answers-btn');
  btn.textContent = mathAnswersShown ? 'Hide Answers' : 'Show Answers';
  if (mathAnswersShown) btn.classList.add('active');
  else btn.classList.remove('active');
  document.querySelectorAll('#math-content .math-a').forEach(a => {
    if (mathAnswersShown) a.classList.add('show');
    else a.classList.remove('show');
  });
}

// Math search with debounce
(function() {
  let timer;
  document.getElementById('math-search').addEventListener('input', function() {
    clearTimeout(timer);
    const q = this.value;
    timer = setTimeout(() => filterMathTopics(q), 200);
  });
})();

function filterMathTopics(query) {
  const q = query.trim().toLowerCase();
  const topics = document.querySelectorAll('#math-content .math-topic');
  let visible = 0;
  topics.forEach(t => {
    if (!q || t.dataset.title.includes(q)) {
      t.classList.remove('math-hidden');
      visible++;
    } else {
      t.classList.add('math-hidden');
    }
  });
  let countEl = document.getElementById('math-search-count');
  if (q) {
    if (!countEl) {
      countEl = document.createElement('div');
      countEl.id = 'math-search-count';
      countEl.className = 'math-search-count';
      document.getElementById('math-content').before(countEl);
    }
    countEl.textContent = `${visible} matching topic${visible !== 1 ? 's' : ''}`;
  } else if (countEl) {
    countEl.remove();
  }
}

// Load math on nav switch
let mathLoaded = false;

checkAuth();
if (document.body.classList.contains('app-mode')) {
  // Try to restore previous deck; fall back to new deck
  (async () => {
    const pool = await fetchWords();
    if (!restoreDeck(pool)) loadDeck();
  })();
}
</script>
</body>
</html>
